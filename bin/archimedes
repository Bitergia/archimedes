# -*- coding: utf-8 -*-
#
# Import and Export Kibana dashboards
#
# Copyright (C) 2014-2018 Bitergia
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Authors:
#   Valerio Cosentino <valcos@bitergia.com>
#

import argparse
import logging
from operator import xor
import sys

from archimedes.archimedes import Archimedes
from archimedes.clients.dashboard import DASHBOARD
from archimedes._version import __version__

# Logging formats
ARCHIMEDES_LOG_FORMAT = "[%(asctime)s] - %(message)s"
ARCHIMEDES_DEBUG_LOG_FORMAT = "[%(asctime)s - %(name)s - %(levelname)s] - %(message)s"
ARCHIMEDES_USAGE_MSG = "usage: archimedes [options]"
ARCHIMEDES_DESC_MSG = "Import and export Kibana dashboards, visualizations, searches and index patterns"
ARCHIMEDES_VERSION_MSG = \
"""%(prog)s """  + __version__


FOLDER_PATH = './'


def config_logging(debug):
    """Config logging level output output"""

    if debug:
        logging.basicConfig(level=logging.DEBUG, format=ARCHIMEDES_DEBUG_LOG_FORMAT)
        logging.debug("Debug mode activated")
    else:
        logging.basicConfig(level=logging.INFO, format=ARCHIMEDES_LOG_FORMAT)


def get_params_parser():
    """Parse command line arguments"""

    parser = argparse.ArgumentParser(usage=ARCHIMEDES_USAGE_MSG,
                                     description=ARCHIMEDES_DESC_MSG,
                                     add_help=False)

    parser.add_argument('-g', '--debug', dest='debug',
                        action='store_true',
                        help=argparse.SUPPRESS)
    parser.add_argument('-h', '--help', action='help',
                        help=argparse.SUPPRESS)
    parser.add_argument('-v', '--version', action='version',
                        version=ARCHIMEDES_VERSION_MSG,
                        help=argparse.SUPPRESS)

    parser.add_argument('url', help='Kibana URL')
    parser.add_argument('--force', dest='force', action='store_true', help='Force overwrite')
    parser.add_argument('--json-path', dest='json_path', help='Path of the JSON file to import')

    group_import = parser.add_argument_group('Import')
    group_import.add_argument('--search', dest='search', action='store_true', help='Search the objects referenced in the file')
    group_import.add_argument('--visualizations-folder', dest='visualizations_folder', help='Folder where visualization objects are stored')
    group_import.add_argument('--searches-folder', dest='searches_folder', help='Folder where search objects are stored')
    group_import.add_argument('--index-patterns-folder', dest='index_patterns_folder', help='Folder where index pattern objects are stored')

    group_export = parser.add_argument_group('Export')
    group_export.add_argument('--obj-type', dest='obj_type', help='Type of the object to export')
    group_export.add_argument('--obj-id', dest='obj_id', help='ID of the object to export')
    group_export.add_argument('--obj-title', dest='obj_title', help='Title of the object to export')
    group_export.add_argument('--folder-path', dest='folder_path', default=FOLDER_PATH, help='Folder where to export the dashboard objects')
    group_export.add_argument('--one-file', dest='one_file', action='store_true', help='Export the dashboard objects to a file')

    exclusive = parser.add_mutually_exclusive_group(required=True)
    exclusive.add_argument('--import', dest='import_objs', action='store_true',
                           help='Import Kibana objects from files')
    exclusive.add_argument('--export', dest='export_objs', action='store_true', help='Export Kibana objects to a file')

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    return parser


def get_params():
    """Get params to execute Archimedes"""

    parser = get_params_parser()
    args = parser.parse_args()

    error = 0

    if not args.url:
        logging.error("Missing Kibana URL")
        error = 1

    if args.import_objs and args.export_objs:
        logging.error("Archimedes requires --import or --export")
        error = 1

    if args.import_objs:
        if not args.json_path:
            logging.error("Import requires --json-path")
            error = 1

    elif args.export_objs:
        if not args.obj_type:
            logging.error("Export requires --obj-type")
            error = 1

        if args.one_file and args.obj_type != DASHBOARD:
            logging.error("Export one-file param is valid only for objects of type dashboard")
            error = 1

        if not xor(bool(args.obj_id), bool(args.obj_title)):
            logging.error("Export requires --obj-id or --obj-title")
            error = 1

    if error:
        parser.print_help()
        sys.exit(1)

    return args


def main():
    args = get_params()
    config_logging(args.debug)
    logging.info("Archimedes will start soon.")

    archimedes = Archimedes(args.url)

    if args.import_objs:
        archimedes.import_from_file(args.json_path, args.search, args.visualizations_folder, args.searches_folder,
                                 args.index_patterns_folder, args.force)
    elif args.export_objs and args.obj_id:
        archimedes.export_by_id(args.obj_type, args.obj_id, args.folder_path, args.one_file, args.force)
    elif args.export_objs and args.obj_title:
        archimedes.export_by_title(args.obj_type, args.obj_title, args.folder_path, args.one_file, args.force)

    logging.info("Archimedes has finished.")


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        s = "\n\nReceived Ctrl-C or other break signal. Exiting.\n"
        sys.stderr.write(s)
        sys.exit(0)
